package cubemxtobazelinternal

import (
	"encoding/xml"
	"log"
	"sync"
)

// Project is the project type for external editors generated by stm32cubemx
type Project interface {
	Info() MxInfo
	Requirements() MxRequirements
	Options() MxOptions
	DeviceName() string
	ProjectFiles() []MxFile
	Components() []MxComponent
	Conditions() []MxCondition
}

// projectImpl can be used to determine all parameters specified by the gpdsc file
type projectImpl struct {
	info         MxInfo
	requirements MxRequirements
	options      MxOptions
	generator    MxGenerator
	components   MxComponents
	conditions   MxConditions
}

// Info returns the cubemx project info
func (p projectImpl) Info() MxInfo {
	return p.info
}

// Requirements returns the cubemx project requirements
func (p projectImpl) Requirements() MxRequirements {
	return p.requirements
}

// Options returns a set of options specific to the microcontroller
func (p projectImpl) Options() MxOptions {
	return p.options
}

// DeviceName returns the name of the target device
func (p projectImpl) DeviceName() string {
	return p.generator.Select.DeviceName
}

// ProjectFiles returns a list of files that will be used to build the executable
func (p projectImpl) ProjectFiles() []MxFile {
	return p.generator.ProjectFiles
}

// Components returns a list of sub components that makes up the project
func (p projectImpl) Components() []MxComponent {
	return p.components.Components
}

// Returns a set of conditional flags that can be enabled
func (p projectImpl) Conditions() []MxCondition {
	return p.conditions.Conditions
}

// ProjectInit parses a raw gpdsc file and initialises the project structure
func ProjectInit(gpdsc []byte) Project {
	project := projectImpl{}

	// Used for multithreading unmarshall
	var wg sync.WaitGroup
	unmarshal := func(f interface{}) {
		defer wg.Done()
		err := xml.Unmarshal(gpdsc, f)
		if err != nil {
			log.Fatal("gpdsc unmarshall failed:\n", err)
		}
	}

	// Unmarshal project info
	wg.Add(1)
	go unmarshal(&project.info)
	// Unmarshal project requirements
	wg.Add(1)
	go unmarshal(&project.requirements)
	// Unmarshal project options
	wg.Add(1)
	go unmarshal(&project.options)
	// Unmarshal project generator
	wg.Add(1)
	go unmarshal(&project.generator)
	// Unmarshal project components
	wg.Add(1)
	go unmarshal(&project.components)
	// Unmarshal project conditions
	wg.Add(1)
	go unmarshal(&project.conditions)

	wg.Wait()

	// Homogenise descriptions for each component
	project.components.homogeniseDescriptions()

	return project
}

// MxInfo describes the generated package
type MxInfo struct {
	Vendor      string `xml:"vendor"`
	Name        string `xml:"name"`
	Description string `xml:"description"`
}

// MxRequirements describes the requirements for project
type MxRequirements struct {
	Languages []MxLanguage `xml:"requirements>languages>language"`
}

// MxLanguage describes the language requirements of the projects
type MxLanguage struct {
	Name    string `xml:"name,attr"`
	Version string `xml:"version,attr"`
}

// MxOptions project options
type MxOptions struct {
	StackSize  MxStack      `xml:"create>project>options>stack"`
	HeapSize   MxHeap       `xml:"create>project>options>heap"`
	DebugProbe MxDebugProbe `xml:"create>project>options>debugProbe"`
}

// MxStack contains the stack size for the given micro
type MxStack struct {
	Size string `xml:"size,attr"`
}

// MxHeap contains the heap size for the given micro
type MxHeap struct {
	Size string `xml:"size,attr"`
}

// MxDebugProbe contains the debugger configuration for the micro
type MxDebugProbe struct {
	Name     string `xml:"name,attr"`
	Protocol string `xml:"protocol,attr"`
}

// MxGenerator contains all project specific files generated for
type MxGenerator struct {
	Select       MxSelect `xml:"generators>generator>select"`
	ProjectFiles []MxFile `xml:"generators>generator>project_files>file"`
}

// MxSelect contains device info for the generated projects
type MxSelect struct {
	DeviceName string `xml:"Dname,attr"`
}

// MxFile contains the source file configurations
type MxFile struct {
	Category  string `xml:"category,attr"`
	Condition string `xml:"condition,attr"`
	Name      string `xml:"name,attr"`
}

// MxComponents holds all components for the generated systems
type MxComponents struct {
	Components []MxComponent `xml:"components>component"`
}

func (c MxComponents) homogeniseDescriptions() {
	// map[group]description
	GroupDescriptions := make(map[string]string)
	// Collect common group descriptions
	for _, component := range c.Components {
		if len(component.Description) > 0 {
			GroupDescriptions[component.Group] = component.Description
		}
	}
	// Apply common group descriptions
	for i, component := range c.Components {
		for group, description := range GroupDescriptions {
			if len(component.Description) == 0 && component.Group == group {
				c.Components[i].Description = description
			}

		}
	}
}

// MxComponent describes one component module
type MxComponent struct {
	Class       string   `xml:"Cclass,attr"`
	Group       string   `xml:"Cgroup,attr"`
	Subsection  string   `xml:"Csub,attr"`
	Version     string   `xml:"Cversion,attr"`
	Description string   `xml:"description"`
	Files       []MxFile `xml:"files>file"`
}

// MxConditions holds a list of conditions for compilation of the project
type MxConditions struct {
	Conditions []MxCondition `xml:"conditions>condition"`
}

// MxCondition holds the information required to define a single condition
type MxCondition struct {
	ID          string    `xml:"id,attr"`
	Description string    `xml:"description"`
	Require     MxRequire `xml:"require"`
}

// MxRequire holds the information of a dependent requirement
type MxRequire struct {
	Compiler string `xml:"Tcompiler,attr"`
}
