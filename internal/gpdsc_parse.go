package cubemxtobazelinternal

import (
	"fmt"
	"log"
	"path/filepath"
)

// Project is the project type for external editors generated by stm32cubemx
type Project interface {
	Info() MxInfo
	Requirements() MxRequirements
	Options() MxOptions
	DeviceName() string
	ProjectFiles() []MxFile
	Components() []MxComponent
	Conditions() []MxCondition
}

// projectImpl can be used to determine all parameters specified by the gpdsc file
type projectImpl struct {
	info         MxInfo
	requirements MxRequirements
	options      MxOptions
	generator    MxGenerator
	components   MxComponents
	conditions   MxConditions
}

// Info returns the cubemx project info
func (p projectImpl) Info() MxInfo {
	return p.info
}

// Requirements returns the cubemx project requirements
func (p projectImpl) Requirements() MxRequirements {
	return p.requirements
}

// Options returns a set of options specific to the microcontroller
func (p projectImpl) Options() MxOptions {
	return p.options
}

// DeviceName returns the name of the target device
func (p projectImpl) DeviceName() string {
	return p.generator.Select.DeviceName
}

// ProjectFiles returns a list of files that will be used to build the executable
func (p projectImpl) ProjectFiles() []MxFile {
	return p.generator.ProjectFiles
}

// Components returns a list of sub components that makes up the project
func (p projectImpl) Components() []MxComponent {
	return p.components.Components
}

// Returns a set of conditional flags that can be enabled
func (p projectImpl) Conditions() []MxCondition {
	return p.conditions.Conditions
}

// MxInfo describes the generated package
type MxInfo struct {
	Vendor      string `xml:"vendor"`
	Name        string `xml:"name"`
	Description string `xml:"description"`
}

// MxRequirements describes the requirements for project
type MxRequirements struct {
	Languages []MxLanguage `xml:"requirements>languages>language"`
}

// MxLanguage describes the language requirements of the projects
type MxLanguage struct {
	Name    string `xml:"name,attr"`
	Version string `xml:"version,attr"`
}

// MxOptions project options
type MxOptions struct {
	StackSize  MxStack      `xml:"create>project>options>stack"`
	HeapSize   MxHeap       `xml:"create>project>options>heap"`
	DebugProbe MxDebugProbe `xml:"create>project>options>debugProbe"`
}

// MxStack contains the stack size for the given micro
type MxStack struct {
	Size string `xml:"size,attr"`
}

// MxHeap contains the heap size for the given micro
type MxHeap struct {
	Size string `xml:"size,attr"`
}

// MxDebugProbe contains the debugger configuration for the micro
type MxDebugProbe struct {
	Name     string `xml:"name,attr"`
	Protocol string `xml:"protocol,attr"`
}

// MxGenerator contains all project specific files generated for
type MxGenerator struct {
	Select       MxSelect `xml:"generators>generator>select"`
	ProjectFiles []MxFile `xml:"generators>generator>project_files>file"`
}

// MxSelect contains device info for the generated projects
type MxSelect struct {
	DeviceName string `xml:"Dname,attr"`
}

// MxFile contains the source file configurations
type MxFile struct {
	Category  string `xml:"category,attr"`
	Condition string `xml:"condition,attr"`
	Name      string `xml:"name,attr"`
}

// MxComponents holds all components for the generated systems
type MxComponents struct {
	Components []MxComponent `xml:"components>component"`
}

func (c MxComponents) homogeniseDescriptions() {
	// map[group]description
	GroupDescriptions := make(map[string]string)
	// Collect common group descriptions
	for _, component := range c.Components {
		if len(component.Description) > 0 {
			GroupDescriptions[component.Group] = component.Description
		}
	}
	// Apply common group descriptions
	for i, component := range c.Components {
		for group, description := range GroupDescriptions {
			if len(component.Description) == 0 && component.Group == group {
				c.Components[i].Description = description
			}

		}
	}
}

// MxComponent describes one component module
type MxComponent struct {
	Class       string   `xml:"Cclass,attr"`
	Group       string   `xml:"Cgroup,attr"`
	Subsection  string   `xml:"Csub,attr"`
	Version     string   `xml:"Cversion,attr"`
	Description string   `xml:"description"`
	Files       []MxFile `xml:"files>file"`
	IncludePath string
}

// MxConditions holds a list of conditions for compilation of the project
type MxConditions struct {
	Conditions []MxCondition `xml:"conditions>condition"`
}

// MxCondition holds the information required to define a single condition
type MxCondition struct {
	ID          string    `xml:"id,attr"`
	Description string    `xml:"description"`
	Require     MxRequire `xml:"require"`
}

// MxRequire holds the information of a dependent requirement
type MxRequire struct {
	Compiler string `xml:"Tcompiler,attr"`
}

func getLibraryIncludePath(component MxComponent) (string, error) {
	files := MxFiles(component.Files)
	headerFiles := files.HeaderFiles().Files()
	includeDir := []string{""}
	for _, file := range headerFiles {
		directory := filepath.Dir(file.Name)
		if includeDir[0] == "" {
			includeDir[0] = directory
		}
		if directory != includeDir[0] {
			includeDir = append(includeDir, directory)
		}
	}
	if len(includeDir) == 1 {
		return includeDir[0], nil
	}
	return "", fmt.Errorf("Multiple include paths found for target:%s\n%s",
		ccLibraryTargetName(component), includeDir)
}

func (c MxComponents) addLibraryIncludePath() MxComponents {
	comps := c.Components
	result := c
	for i, component := range comps {
		includePath, err := getLibraryIncludePath(component)
		if err != nil {
			log.Fatal(err)
		}
		result.Components[i].IncludePath = includePath
	}
	return result
}
